<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cyggnb.github.io</id>
    <title>春雨栖迟於一丘</title>
    <updated>2021-04-27T16:02:26.894Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cyggnb.github.io"/>
    <link rel="self" href="https://cyggnb.github.io/atom.xml"/>
    <subtitle>北国风光，千里冰封，万里雪飘。</subtitle>
    <logo>https://cyggnb.github.io/images/avatar.png</logo>
    <icon>https://cyggnb.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 春雨栖迟於一丘</rights>
    <entry>
        <title type="html"><![CDATA[Java复习]]></title>
        <id>https://cyggnb.github.io/post/java-fu-xi/</id>
        <link href="https://cyggnb.github.io/post/java-fu-xi/">
        </link>
        <updated>2021-04-27T16:01:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="第1章">第1章</h2>
<p>使用javac可以将Java源代码(后缀为.java)编译成字节码（后缀为.class），字节码在JVM中运行</p>
<p>当编译但愿中有public类时，主文件名必须与public类的类名相同</p>
<p>Java程序在任何地方都区分大小写</p>
<h2 id="第2章">第2章</h2>
<p>Scanner类存放在java.util包中，所以使用时需要import java.util.Scanner</p>
<p>标识符：变量、方法、类的名字，用字母，下划线和$开头，区分大小写</p>
<p>关键字：一些动作，如int double this switch都是关键字</p>
<p>float型占32位，称为单精度型。double型占64位，称为双精度型。</p>
<p>float型值必须加F或f，如</p>
<pre><code class="language-java">float pi = 3.1415926F
</code></pre>
<p>Java采用的是Unicode编码，但是也兼容ASCII编码，比如</p>
<pre><code class="language-java">char c2 = 65;
System.out.println(62);	//输出字符A


int i = 66;
char c = 'A';
int n = i + c;	//合法，c自动转换为int型
c = i;					//不合法，i不能自动转为为char型
</code></pre>
<p>转义字符不怎么用但是要知道的几个</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>说明</th>
<th>转义字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\'</td>
<td>单引号字符</td>
<td>\b</td>
<td>退格</td>
</tr>
<tr>
<td>\``</td>
<td>双引号字符</td>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\\</td>
<td>反斜杠字符</td>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\f</td>
<td>换页</td>
<td>\t</td>
<td>水平制表符</td>
</tr>
</tbody>
</table>
<p>x++用的还是x值，而++x用的是加完之后的值</p>
<h2 id="第3章">第3章</h2>
<p>可以使用<code>Math.random( )</code>方法产生一个0.0～1.0的随机double值，不包括1.0，采用一定的运算方法可以获得一定范围的随机数</p>
<p>switch(expression)<code>中</code>expression<code>可以是</code>byte，short，int，char，enum<code>或</code>String`类型</p>
<p>break是结束当前循环，continue是结束当前这一轮循环的剩余部分，开始进行下一轮循环。continue语句可以带标签，用来标识从那层循环继续执行。</p>
<h2 id="第4章">第4章</h2>
<p>面向对象基本特征：封装 继承 多态</p>
<p>类声明的一般格式为：</p>
<pre><code>[public][abstract|final] class Classname [extends SuperClass][implements InterfaceNamelist]{
	//1.成员变量声明
	//2.构造方法的定义
	//3.成员方法的定义
}
</code></pre>
<p>public公共变量可以被任何方法访问；protected保护变量只能被同一包中的类或子类访问；private私有变量只能被同一个类的方法访问</p>
<p>final修饰的变量叫做最终变量，不一定要马上赋值，可以在之后赋值，但是赋值后就不能被改变了。用final修饰的方法称为最终方法，最终方法不能被覆盖。</p>
<p>对于对象的赋值是将对象的引用（地址）赋值给变量</p>
<pre><code class="language-java">Employee emp1 = new Employee();
Employee emp2 = emp1;	//将emp1的引用赋给emp2，即两者指向同一个对象
</code></pre>
<p>内存从逻辑上分为栈与堆，当Java程序运行时，被调用方法参数和方法中定义的局部变量都存储在内存栈中，当程序使用new运算符创建对象时，JVM将在堆中分配内存</p>
<p>方法重载要求同名的方法要么个数不同，要么参数类型不同，仅返回值不同不能区分重载的方法。</p>
<p>静态变量在被创建时分配了一块内存，以后再生成所属的类的对象时，用的都是同一个y，即使没有所属的类的实例时还是只有一个y，与final结合使用可防止静态变量被修改。</p>
<p>静态方法属于类，只能访问静态变量。实例方法可对实例变量和静态变量操作。</p>
<p>单例模式要求声明为private，并定义一个static final构造方法。</p>
<h2 id="第5章">第5章</h2>
<p>Java声明数组方法和C/C++有些许不同，提供了两种等价的方法：</p>
<pre><code class="language-java">elementType []arraryName;
elementType arrayName[];
</code></pre>
<p>数组是一个对象，使用前同样要new来分配内存空间</p>
<p>在{ }中直接给出数组元素时，数组无法指定大小，只能根据元素个数来自动分配。</p>
<p>增强的for循环：对数组或集合中的每个元素identifier执行一次循环体中的语句，下面为求marks[]中各元素的和：</p>
<pre><code class="language-java">double sum = 0;
for(double score : marks){
	sum = sum + score;
}
//score对应的是数组中的每个元素
</code></pre>
<p>使用arraycopy()方法可以将源数组的一部分元素复制到目标数组中。需要注意目标数组的长度要足以容纳源数组元素。</p>
<pre><code class="language-java">import java.util.Arrays;

public class HelloWorld {

    public static void main(String[] args) {
        int[] numbers = {3, 7, 9};
        int[] newArray = Arrays.copyOf(numbers, 4);
      	//这里顺带创建了一个长度为4的数组，将numbers中的元素复制过去
      	//如果数组容量不足，则能复制几个就复制几个
        for (int a :
                newArray
        ) {
            System.out.println(a);
        }
    }
}
</code></pre>
<h2 id="第6章">第6章</h2>
<p>String类是不变字符串，StringBuilder和StringBuffer是可变字符串，都被声明为final，所以不可被继承。</p>
<pre><code class="language-java">public class HelloWorld {

    public static void main(String[] args) {
        String a = &quot;HelloWorld&quot;;
        System.out.println(a.substring(1));
        System.out.println(a.substring(1,3));
    }
}
//输出结果为：
//elloWorld
//el
</code></pre>
<p>字符串的下标和数组一样，从0开始而不是从1开始，</p>
<p>字符串的子字符串（1，3）不包括3，左闭右开</p>
<p>String对象的不变性：String一旦被创建就不能对其内容进行改变。有些方法看起来像是改变了字符串，实际上是在原来的字符串的基础上创建了一个新的字符串。</p>
<p>字符串 常量存储在常量池中，所以内容相同的字符串实际上就是同一个</p>
<pre><code class="language-java">String s1 = &quot;Hello World&quot;;String s2 = &quot;Hello World&quot;;System.out.println(s1 == s2);	//输出true
</code></pre>
<p>创建StringBuilder对象时，系统会多分配16个字符的缓冲区来方便修改，如果修改之后超出了缓冲区，则将容量修改为 （原容量+1）的两倍</p>
<h2 id="第7章">第7章</h2>
<p>关于类继承的几点说明：<br>
1.子类只继承非private的变量和方法</p>
<p>2.定义类时若缺省extends关键字，则所定义的类为java.lang.Object类的直接子类。一切类都是Object的直接子类或者间接子类。</p>
<p>3.Java仅支持单重继承，并不是只能继承一级，是只能有一个父类。</p>
<p>使用@override注解，表示后面的方法必须是覆盖父类的一个方法，编译时会进行检查。如果没有覆盖会报错。</p>
<p>private方法不能被覆盖，父类的private方法和子类无关，子类爱怎么做怎么做，不是同一个。子类中的方法要是想覆盖父类中的方法，名字，参数，返回类型都要相同，仅仅是名字相同认为是重载。</p>
<ul>
<li>方法重载（只看参数）与下列因素相关（参数列表不一样）：<br>
1.参数个数不同<br>
2.参数类型不同<br>
3，参数的多类型顺序不同</li>
<li>方法重载于下列因素无关<br>
1.与参数的名称无关<br>
2.与方法的返回值类型无关</li>
</ul>
<p>static方法能被继承但不能被覆盖。static方便在没有创建对象的情况下来进行调用（方法/变量）。很显然，被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。</p>
<p>super用来访问父类中的方法和变量。</p>
<p>子类不能继承父类的构造方法，所以创建子类时要用默认构造方法或者为子类定义构造方法。</p>
<p>一个类在包中，若访问修饰符（public private）为缺省，则只能被同一个包中的类访问，若要被包外访问，则需要加上public修饰符。</p>
<p>private只能被当前类本身访问，上文提到了，子类都看不到。</p>
<p>缺省只能被当前类本身和同一个包中的类访问，子类同样看不到</p>
<p>protected在缺省的基础上可以被子类看到，但包外的还是看不到</p>
<p>public就是公交车了，在哪都能用</p>
<p>final就是终极类，不能再被做任何改变，就是这样写死了。也不能被子类覆盖</p>
<p>当一个变量被final修饰时，一旦这个变量被赋值就不能再被改变，但是不一定要马上给出值。</p>
<p>抽象方法为所有子类提供了一个统一的接口，不能马上写实现方法，只是说有这么一回事。抽象类中可以没有抽象方法，但仍然需要被子类继承才能实例化。即abstract类必须被继承，否则没有意义</p>
<pre><code class="language-java">public abstract class Shape {    String name;    public Shape() {    }    public Shape(String name) {        this.name = name;    }		//可以定义构造方法    public abstract double getArea();    public abstract double getPerimeter();}
</code></pre>
<p>子类继承了父类的所有数据和行为，所以子类对象可以直接转换为父类。父类也可以转换为子类，但父类对象必须由子类构造方法生成。</p>
<p>转换只发生在有继承关系的类和接口之间。</p>
<h2 id="第8章">第8章</h2>
<h2 id="第9章">第9章</h2>
<p>枚举类型：enum，作为关键字可以定义enum = e1,即e1的值为enum中的值，可以用在switch中，</p>
<h2 id="第10章">第10章</h2>
<p>接口允许多继承，而类只允许单继承</p>
<p>一个类实现多个接口就要实现每个接口中的抽象方法。接口中的常量和默认方法都被实现类继承，但接口中的静态方法不被继承。</p>
<p>接口也是一种饮用类型，任何实现该接口的实例都可以存储在该接口类型的变量中，实例中的实现可以直接用，系统会自己寻找用哪个。</p>
<p>定义在接口中的任何变量都自动加上public、final、static属性。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[优联方案96配列TTC金粉轴植物园键帽观赏]]></title>
        <id>https://cyggnb.github.io/post/you-lian-fang-an-96-pei-lie-ttc-jin-fen-zhou-zhi-wu-yuan-jian-mao/</id>
        <link href="https://cyggnb.github.io/post/you-lian-fang-an-96-pei-lie-ttc-jin-fen-zhou-zhi-wu-yuan-jian-mao/">
        </link>
        <updated>2021-04-25T08:51:38.000Z</updated>
        <content type="html"><![CDATA[<p>诶，就是玩儿～<br>
<img src="https://cyggnb.github.io/post-images/1619340908885.JPG" alt="" loading="lazy"><br>
个人很喜欢线性轴（其实也就是接近薄膜的手感），打起来没有段落轴那么吵，不会很影响别人。<br>
相比niz静电容那种闷闷的声音，金粉轴确实会更加清脆（大声）一些，相比之下还是更喜欢静电容。<br>
<img src="https://cyggnb.github.io/post-images/1619340914627.JPG" alt="" loading="lazy"><br>
<img src="https://cyggnb.github.io/post-images/1619340920583.JPG" alt="" loading="lazy"><br>
<img src="https://cyggnb.github.io/post-images/1619340925721.JPG" alt="" loading="lazy"><br>
最后来一张桌面图吧（没有上床下桌只能自己买折叠桌，我恨啊！）<br>
<img src="https://cyggnb.github.io/post-images/1619354171022.jpg" alt="" loading="lazy"></p>
<p>机械键盘退烧了，再也不买了=。=</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树莓派篇一：利用Telegram-cli实现自动签到]]></title>
        <id>https://cyggnb.github.io/post/树莓派篇一：利用Telegram-cli实现自动签到/</id>
        <link href="https://cyggnb.github.io/post/树莓派篇一：利用Telegram-cli实现自动签到/">
        </link>
        <updated>2021-01-26T08:16:21.000Z</updated>
        <summary type="html"><![CDATA[<p>部分网站在<code>Telegram</code>上利用类似<code>/checkin</code>的指令进行签到，每次都能获得不等的流量，长期签到足以满足日常的使用。但每天手动签到就显得十分麻烦。因此，本文带来利用<code>Telegram-cli</code>在<code>Linux</code>上实现自动签到。</p>
]]></summary>
        <content type="html"><![CDATA[<p>部分网站在<code>Telegram</code>上利用类似<code>/checkin</code>的指令进行签到，每次都能获得不等的流量，长期签到足以满足日常的使用。但每天手动签到就显得十分麻烦。因此，本文带来利用<code>Telegram-cli</code>在<code>Linux</code>上实现自动签到。</p>
<!-- more -->
<h2 id="前言">前言</h2>
<p>部分网站在<code>Telegram</code>上利用类似<code>/checkin</code>的指令进行签到，每次都能获得不等的流量，长期签到足以满足日常的使用。但每天手动签到就显得十分麻烦。因此，本文带来利用<code>Telegram-cli</code>在<code>Linux</code>上实现自动签到。</p>
<h2 id="前期准备">前期准备</h2>
<ul>
<li>
<p><code>Linux</code>环境（演示采用的是<code>Ubuntu Server</code>）</p>
</li>
<li>
<p>网站支持<code>Telegram</code>签到</p>
</li>
</ul>
<h2 id="telegram-cli-安装编译">Telegram-cli 安装编译</h2>
<h4 id="1下载telegram-cli">1.下载<code>Telegram-cli</code></h4>
<pre><code class="language-bash">git clone --recursive https://github.com/vysheng/tg.git &amp;&amp; cd tg
</code></pre>
<h4 id="2安装依赖">2.安装依赖</h4>
<pre><code class="language-bash">#Ubuntu系统
sudo apt-get update
sudo apt-get install libreadline-dev libconfig-dev libssl-dev lua5.2 liblua5.2-dev libevent-dev libjansson-dev libpython3-dev make
</code></pre>
<p><strong>其他系统安装教程请自行点击查询</strong><a href="https://github.com/cyggnb/tgAutoSendMessange">https://github.com/cyggnb/tgAutoSendMessange</a></p>
<p>原安装文档中安装的是<code>libpython-dev</code>在新版Ubuntu中需要指定<code>python</code>版本才可安装，同时不建议安装<code>python2</code>版本的包</p>
<p>编译过程中如果编译失败，查看日志百度搜索即可</p>
<h4 id="3激活telegram-api">3.激活<code>Telegram API</code></h4>
<p>在<a href="https://www.yikzero.com/go/aHR0cHM6Ly9teS50ZWxlZ3JhbS5vcmcvYXBwcw=="><code>https://my.telegram.org/apps</code></a>里申请一个<code>key</code>，然后复制保存下来，登录账号记得要打<strong>国际区号</strong><br>
<a href="https://www.yikzero.com/usr/uploads/2020/08/2664344034.png"><img src="https://www.yikzero.com/usr/uploads/2020/08/2664344034.png" alt="img" loading="lazy"></a></p>
<p>输入<code>验证码</code>后，将获取到的<code>key</code>保存成<code>pub</code>文件<br>
<a href="https://www.yikzero.com/usr/uploads/2020/08/1920994944.png"><img src="https://www.yikzero.com/usr/uploads/2020/08/1920994944.png" alt="img" loading="lazy"></a></p>
<pre><code class="language-bash">vi /root/tg-server.pub
</code></pre>
<h4 id="4测试">4.测试</h4>
<pre><code class="language-bash">/root/tg/bin/telegram-cli -k /root/tg-server.pub
</code></pre>
<p>在输入框中可以输入以下内容测试能否发送信息并签到</p>
<pre><code class="language-bash">msg &lt;频道&gt; &lt;check-in的指令&gt;
#example
#msg xxairport /checkin
</code></pre>
<p>测试成功后按下<code>Ctrl+C</code>退出</p>
<h2 id="创建自动运行脚本">创建自动运行脚本</h2>
<pre><code class="language-bash">cd /root
vi autotg.sh
</code></pre>
<p>复制以下内容进去，用你自己的<code>频道</code>和<code>check-in</code>的指令，请注意，因为<code>telegram-cli</code>的特殊形式，<code>指令</code>或<code>频道名</code>中包含的所有空格必须转换成下划线：</p>
<pre><code class="language-bash">#!/bin/bash
#Author: cygg
/root/tg/bin/telegram-cli -W -e &quot;msg &lt;频道&gt; &lt;check-in的指令&gt;&quot;
</code></pre>
<p>保存后给脚本执行权限</p>
<pre><code class="language-bash">chmod +x autotg.sh
</code></pre>
<p>测试</p>
<pre><code class="language-bash">bash autotg.sh
</code></pre>
<h2 id="添加定时脚本">添加定时脚本</h2>
<h4 id="编辑crontab">编辑<code>crontab</code></h4>
<pre><code class="language-bash">crontab -e
</code></pre>
<h4 id="添加如下两条记录">添加如下两条记录</h4>
<p><strong>(每天签到一次，十二小时后补签一次，要注意服务器的时区)</strong></p>
<pre><code class="language-bash">30 2 * * * bash /root/autotg.sh
30 14 * * * bash /root/autotg.sh
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://cyggnb.github.io/post/hello-gridea/</id>
        <link href="https://cyggnb.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>