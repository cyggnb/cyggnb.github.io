{"posts":[{"title":"Java复习","content":"第1章 使用javac可以将Java源代码(后缀为.java)编译成字节码（后缀为.class），字节码在JVM中运行 当编译但愿中有public类时，主文件名必须与public类的类名相同 Java程序在任何地方都区分大小写 第2章 Scanner类存放在java.util包中，所以使用时需要import java.util.Scanner 标识符：变量、方法、类的名字，用字母，下划线和$开头，区分大小写 关键字：一些动作，如int double this switch都是关键字 float型占32位，称为单精度型。double型占64位，称为双精度型。 float型值必须加F或f，如 float pi = 3.1415926F Java采用的是Unicode编码，但是也兼容ASCII编码，比如 char c2 = 65; System.out.println(62); //输出字符A int i = 66; char c = 'A'; int n = i + c; //合法，c自动转换为int型 c = i; //不合法，i不能自动转为为char型 转义字符不怎么用但是要知道的几个 转义字符 说明 转义字符 说明 \\' 单引号字符 \\b 退格 \\`` 双引号字符 \\r 回车 \\\\ 反斜杠字符 \\n 换行 \\f 换页 \\t 水平制表符 x++用的还是x值，而++x用的是加完之后的值 第3章 可以使用Math.random( )方法产生一个0.0～1.0的随机double值，不包括1.0，采用一定的运算方法可以获得一定范围的随机数 switch(expression)中expression可以是byte，short，int，char，enum或String`类型 break是结束当前循环，continue是结束当前这一轮循环的剩余部分，开始进行下一轮循环。continue语句可以带标签，用来标识从那层循环继续执行。 第4章 面向对象基本特征：封装 继承 多态 类声明的一般格式为： [public][abstract|final] class Classname [extends SuperClass][implements InterfaceNamelist]{ //1.成员变量声明 //2.构造方法的定义 //3.成员方法的定义 } public公共变量可以被任何方法访问；protected保护变量只能被同一包中的类或子类访问；private私有变量只能被同一个类的方法访问 final修饰的变量叫做最终变量，不一定要马上赋值，可以在之后赋值，但是赋值后就不能被改变了。用final修饰的方法称为最终方法，最终方法不能被覆盖。 对于对象的赋值是将对象的引用（地址）赋值给变量 Employee emp1 = new Employee(); Employee emp2 = emp1; //将emp1的引用赋给emp2，即两者指向同一个对象 内存从逻辑上分为栈与堆，当Java程序运行时，被调用方法参数和方法中定义的局部变量都存储在内存栈中，当程序使用new运算符创建对象时，JVM将在堆中分配内存 方法重载要求同名的方法要么个数不同，要么参数类型不同，仅返回值不同不能区分重载的方法。 静态变量在被创建时分配了一块内存，以后再生成所属的类的对象时，用的都是同一个y，即使没有所属的类的实例时还是只有一个y，与final结合使用可防止静态变量被修改。 静态方法属于类，只能访问静态变量。实例方法可对实例变量和静态变量操作。 单例模式要求声明为private，并定义一个static final构造方法。 第5章 Java声明数组方法和C/C++有些许不同，提供了两种等价的方法： elementType []arraryName; elementType arrayName[]; 数组是一个对象，使用前同样要new来分配内存空间 在{ }中直接给出数组元素时，数组无法指定大小，只能根据元素个数来自动分配。 增强的for循环：对数组或集合中的每个元素identifier执行一次循环体中的语句，下面为求marks[]中各元素的和： double sum = 0; for(double score : marks){ sum = sum + score; } //score对应的是数组中的每个元素 使用arraycopy()方法可以将源数组的一部分元素复制到目标数组中。需要注意目标数组的长度要足以容纳源数组元素。 import java.util.Arrays; public class HelloWorld { public static void main(String[] args) { int[] numbers = {3, 7, 9}; int[] newArray = Arrays.copyOf(numbers, 4); //这里顺带创建了一个长度为4的数组，将numbers中的元素复制过去 //如果数组容量不足，则能复制几个就复制几个 for (int a : newArray ) { System.out.println(a); } } } 第6章 String类是不变字符串，StringBuilder和StringBuffer是可变字符串，都被声明为final，所以不可被继承。 public class HelloWorld { public static void main(String[] args) { String a = &quot;HelloWorld&quot;; System.out.println(a.substring(1)); System.out.println(a.substring(1,3)); } } //输出结果为： //elloWorld //el 字符串的下标和数组一样，从0开始而不是从1开始， 字符串的子字符串（1，3）不包括3，左闭右开 String对象的不变性：String一旦被创建就不能对其内容进行改变。有些方法看起来像是改变了字符串，实际上是在原来的字符串的基础上创建了一个新的字符串。 字符串 常量存储在常量池中，所以内容相同的字符串实际上就是同一个 String s1 = &quot;Hello World&quot;;String s2 = &quot;Hello World&quot;;System.out.println(s1 == s2); //输出true 创建StringBuilder对象时，系统会多分配16个字符的缓冲区来方便修改，如果修改之后超出了缓冲区，则将容量修改为 （原容量+1）的两倍 第7章 关于类继承的几点说明： 1.子类只继承非private的变量和方法 2.定义类时若缺省extends关键字，则所定义的类为java.lang.Object类的直接子类。一切类都是Object的直接子类或者间接子类。 3.Java仅支持单重继承，并不是只能继承一级，是只能有一个父类。 使用@override注解，表示后面的方法必须是覆盖父类的一个方法，编译时会进行检查。如果没有覆盖会报错。 private方法不能被覆盖，父类的private方法和子类无关，子类爱怎么做怎么做，不是同一个。子类中的方法要是想覆盖父类中的方法，名字，参数，返回类型都要相同，仅仅是名字相同认为是重载。 方法重载（只看参数）与下列因素相关（参数列表不一样）： 1.参数个数不同 2.参数类型不同 3，参数的多类型顺序不同 方法重载于下列因素无关 1.与参数的名称无关 2.与方法的返回值类型无关 static方法能被继承但不能被覆盖。static方便在没有创建对象的情况下来进行调用（方法/变量）。很显然，被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。 super用来访问父类中的方法和变量。 子类不能继承父类的构造方法，所以创建子类时要用默认构造方法或者为子类定义构造方法。 一个类在包中，若访问修饰符（public private）为缺省，则只能被同一个包中的类访问，若要被包外访问，则需要加上public修饰符。 private只能被当前类本身访问，上文提到了，子类都看不到。 缺省只能被当前类本身和同一个包中的类访问，子类同样看不到 protected在缺省的基础上可以被子类看到，但包外的还是看不到 public就是公交车了，在哪都能用 final就是终极类，不能再被做任何改变，就是这样写死了。也不能被子类覆盖 当一个变量被final修饰时，一旦这个变量被赋值就不能再被改变，但是不一定要马上给出值。 抽象方法为所有子类提供了一个统一的接口，不能马上写实现方法，只是说有这么一回事。抽象类中可以没有抽象方法，但仍然需要被子类继承才能实例化。即abstract类必须被继承，否则没有意义 public abstract class Shape { String name; public Shape() { } public Shape(String name) { this.name = name; } //可以定义构造方法 public abstract double getArea(); public abstract double getPerimeter();} 子类继承了父类的所有数据和行为，所以子类对象可以直接转换为父类。父类也可以转换为子类，但父类对象必须由子类构造方法生成。 转换只发生在有继承关系的类和接口之间。 第8章 第9章 枚举类型：enum，作为关键字可以定义enum = e1,即e1的值为enum中的值，可以用在switch中， 第10章 接口允许多继承，而类只允许单继承 一个类实现多个接口就要实现每个接口中的抽象方法。接口中的常量和默认方法都被实现类继承，但接口中的静态方法不被继承。 接口也是一种饮用类型，任何实现该接口的实例都可以存储在该接口类型的变量中，实例中的实现可以直接用，系统会自己寻找用哪个。 定义在接口中的任何变量都自动加上public、final、static属性。 ","link":"https://cyggnb.github.io/post/java-fu-xi/"},{"title":"优联方案96配列TTC金粉轴植物园键帽观赏","content":"诶，就是玩儿～ 个人很喜欢线性轴（其实也就是接近薄膜的手感），打起来没有段落轴那么吵，不会很影响别人。 相比niz静电容那种闷闷的声音，金粉轴确实会更加清脆（大声）一些，相比之下还是更喜欢静电容。 最后来一张桌面图吧（没有上床下桌只能自己买折叠桌，我恨啊！） 机械键盘退烧了，再也不买了=。= ","link":"https://cyggnb.github.io/post/you-lian-fang-an-96-pei-lie-ttc-jin-fen-zhou-zhi-wu-yuan-jian-mao/"},{"title":"树莓派篇一：利用Telegram-cli实现自动签到","content":"部分网站在Telegram上利用类似/checkin的指令进行签到，每次都能获得不等的流量，长期签到足以满足日常的使用。但每天手动签到就显得十分麻烦。因此，本文带来利用Telegram-cli在Linux上实现自动签到。 前言 部分网站在Telegram上利用类似/checkin的指令进行签到，每次都能获得不等的流量，长期签到足以满足日常的使用。但每天手动签到就显得十分麻烦。因此，本文带来利用Telegram-cli在Linux上实现自动签到。 前期准备 Linux环境（演示采用的是Ubuntu Server） 网站支持Telegram签到 Telegram-cli 安装编译 1.下载Telegram-cli git clone --recursive https://github.com/vysheng/tg.git &amp;&amp; cd tg 2.安装依赖 #Ubuntu系统 sudo apt-get update sudo apt-get install libreadline-dev libconfig-dev libssl-dev lua5.2 liblua5.2-dev libevent-dev libjansson-dev libpython3-dev make 其他系统安装教程请自行点击查询https://github.com/cyggnb/tgAutoSendMessange 原安装文档中安装的是libpython-dev在新版Ubuntu中需要指定python版本才可安装，同时不建议安装python2版本的包 编译过程中如果编译失败，查看日志百度搜索即可 3.激活Telegram API 在https://my.telegram.org/apps里申请一个key，然后复制保存下来，登录账号记得要打国际区号 输入验证码后，将获取到的key保存成pub文件 vi /root/tg-server.pub 4.测试 /root/tg/bin/telegram-cli -k /root/tg-server.pub 在输入框中可以输入以下内容测试能否发送信息并签到 msg &lt;频道&gt; &lt;check-in的指令&gt; #example #msg xxairport /checkin 测试成功后按下Ctrl+C退出 创建自动运行脚本 cd /root vi autotg.sh 复制以下内容进去，用你自己的频道和check-in的指令，请注意，因为telegram-cli的特殊形式，指令或频道名中包含的所有空格必须转换成下划线： #!/bin/bash #Author: cygg /root/tg/bin/telegram-cli -W -e &quot;msg &lt;频道&gt; &lt;check-in的指令&gt;&quot; 保存后给脚本执行权限 chmod +x autotg.sh 测试 bash autotg.sh 添加定时脚本 编辑crontab crontab -e 添加如下两条记录 (每天签到一次，十二小时后补签一次，要注意服务器的时区) 30 2 * * * bash /root/autotg.sh 30 14 * * * bash /root/autotg.sh ","link":"https://cyggnb.github.io/post/树莓派篇一：利用Telegram-cli实现自动签到/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://cyggnb.github.io/post/hello-gridea/"}]}